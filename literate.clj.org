* Counter

#+begin_src clojure
(defn counter []
  (let [cnt (r/atom 0)]
    (fn []
      [:div
       (str @cnt)
       [:button {:on-click #(swap! cnt inc)} "Increment!"]])))
#+end_src

* Temperature Converter

The input should only update if it contains a valid float.

If the current state of the form is "12" and the user wants to change it to "-52", they will to go through an intermediary state of "" (the empty string). =js/parseFloat= parses "" as =NaN=.

Something similar happens if the current state of the form is "2" and the user wants it to be "2.5". =js/parseFloat= parses the "2." as "2". The user will be unable to enter a decimal point!

To solve this, we need to validate the user's input, and only update the ratom that tracks the field's state if the current state of the field is valid.

In this example, =@input= tracks the state of the input field.
When =@input= is modified, the state of the field changes with it.
When the state of the field changes, =@input= only changes if the current state of the field is deemed valid.

#+begin_src
[2|   ] => @input = 2   ;; @input tracks the state of the field.
[2.|  ] => @input = 2   ;; Invalid input: state did not update.
[2.5| ] => @input = 2.5 ;; Valid input: state did update.
[2.|  ] => @input = 2.5 ;; Invalid input: state did not update.
[2|   ] => @input = 2   ;; etc.
[|    ] => @input = 2
[-|   ] => @input = 2
[-1|  ] => @input = -1
[-12| ] => @input = -12
#+end_src

#+begin_src clojure
(defn f->c [f]
  (* (- f 32) (/ 5 9)))

(defn c->f [c]
  (+ 32 (* c (/ 9 5))))

(defn valid-float? [s]
  (= s (-> s js/parseFloat str)))

(defn temperature-input [value is-valid-fn]
  (let [valid (r/atom true)]
    (fn []
      [:input {:class (if @valid "valid" "invalid")
               :value @value
               ;; You shouldn't have to manually delete the whole contents of the input
               :on-click (fn [e]
                           (. (.-target e) focus)
                           (. (.-target e) select))
               :on-change (fn [e]
                            (let [v (-> e .-target .-value)]
                              (reset! value v)
                              (if (valid-float? v)
                                (do
                                  (reset! valid true)
                                  (is-valid-fn v))
                                (reset! valid false))))}])))

(defn temperature-converter []
  (let [celsius-input (r/atom 0)
        fahrenheit-input (r/atom (c->f @celsius-input))]
    (fn []
      [:div
       [:div "Celsius: "
        [temperature-input celsius-input #(reset! fahrenheit-input (c->f %))]]
       [:div "Fahrenheit: "
        [temperature-input fahrenheit-input #(reset! celsius-input (f->c %))]]])))
#+end_src

* Flight Booker

Our temperature converter had two fields, the state of each dependent on that of the other.  In this simple scenario, it made sense to store the state as two ratoms, and allow each field to freely modify the state of the other.

Here, we have multiple inputs that each need to know the status of multiple /other/ inputs. In this scenario, it will be much simpler to bundle the full component state into a single ratom, which can be supplied to each input to read and write.

Validation needs to work differently here, too. Where the temperature inputs only needed to deal with two states (valid or invalid float), our date input needs a third: incomplete.

For example: neither "05/03/2" nor "99/03/2021" is a valid date input. But in the former case, it's possible (and likely) that the user is in the middle of filling in a valid date, whereas in the latter we know that the input cannot be valid.

We don't want our validator "crying wolf" as the user is trying to fill out the form. It's annoying, disrespectful ("you're doing it wrong! you're doing it wrong!") reduces our credibility in the case that there's actually something wrong with the input. Modeling an incomplete state allows us to avoid telling the user they're wrong unless we /know/ they're wrong.

Checking for date validity:
Make a JS date object from the date string.

Check if there are any NaNs in the Day, Month, or Year fields. This will alert us to an invalid date, even if it is incomplete.

JS will "coerce" some invalid dates, e.g. Nov 11, or Feb 29 of a non-leap year will become Dec 1 or Mar 1.

FIrst: check for NaNs. If nans, invalid.
Second: check completeness. If complete...
Finally: Check coercions. If no coercions: complete. Otherwise: invalid.

Our input forms need to be a bit more complex than in the Temperature Converter. 

It accepts a =context= prop which is expected to contain the full component state, and a =value= prop which is expected to be the key representing the state of the current input.

=flight-date-input= also allows us to pass in functions to determine if the field should be valid (a function of the field's current value) and disabled (a function of the component's state).

With =flight-date-input=, we could be moving towards a customizable general-purpose input field component.

If we wanted to, we could re-implement the Temperature Converter using =flight-date-input=. I don't think it makes sense to do that yet: It would make Temperature Conerter a bit more complex and less clear, and two different types of input field isn't too hard to keep track of. But in an application with a lot of subtly different input fields (more than the present two, at least) it might be simpler to have a single input field component that can be customized to suit many purposes.

#+begin_src clojure
(defn validate-date-str [s]
  (let [js-date (js/Date. s)]
    (when (not-every? js/Number.isNaN [(.getMonth js-date) (.getDay js-date) (.getYear js-date)])
      js-date)))

(defn flight-type-input [state]
  [:select {:value (@state :flight-type)
            :on-change
            (fn [e]
              (swap! state #(assoc % :flight-type (-> e .-target .-value))))}
   [:option {:value "one-way"} "One-Way"]
   [:option {:value "round-trip"} "Round-Trip"]])

(defn flight-date-input [{:keys [context value invalid-when disabled-when]}]
  (let [invalid (r/atom false)]
    (fn []
      [:input {:class
               (when @invalid
                 "invalid")
               :disabled (when
                          (and disabled-when
                               (disabled-when @context))
                           true)
               :value (@context value)
               :on-change (fn [e]
                            (let [v (-> e .-target .-value)]
                              (swap! context #(assoc % value v))))}])))

(defn flight-submit-button [{:keys [context disabled-when]}]
  [:button
   {:disabled (when
               (and disabled-when
                    (disabled-when @context))
                true)
    :on-click (fn [e] (js/console.log (@context :departure-date)))}
   "Submit"])

(defn flight-booker []
  (let [state (r/atom {:flight-type "one-way"
                       :departure-date ""
                       :return-date ""})]
    (fn []
      [:div
       [flight-type-input state]
       [flight-date-input {:context state
                           :value :departure-date
                           :invalid-when nil}]
       [flight-date-input {:context state
                           :value :return-date
                           :invalid-when nil
                           :disabled-when (fn [ctx] (= (:flight-type ctx) "one-way"))}]
       [flight-submit-button {:context state
                              :disabled-when
                              (fn [ctx]
                                (some nil?
                                      (map validate-date-str
                                           [(:departure-date ctx)
                                            (:return-date ctx)])))}]])))


#+end_src

* Circles
Add circle:
Push radius and position to circles vector.
Push =:circle= to undo vector.
Clear redo vector.

Resize circle:
Push circle index and current radius to undo vector
Assoc the new radius onto the circle
Clear redo vector.

Undo:
Look at the last item in the undo vector.
If it's =:create=, we're undoing circle creation.
Push =:create= and the circle's position to the redo vector.
Remove the last circle from the circles vector 

If it's an index and a radius, we're undoing a resize:
Push the index and current radius to redo vector.
Assoc the radius from the undo vector item onto the corresponding item in the circles vector.

Redo:
Look at the last item in the redo vector.

If it's =:create= and position, we're redoing circle creation.
Remove the last item from the redo vector.
Push radius and position to circles vector.
Push =:circle= to undo vector.

If it's an index and a radius, we're redoing a resize.
Push circle index and current radius to undo vector
Assoc the new radius onto the circle

The prompt calls for the radius adjustment control to appear in a popup window, but this is a pretty bad idea on the web.  Instead, we're going to have it replace the Undo and Redo controls, which shouldn't be usable during radius adjustment anyway.
